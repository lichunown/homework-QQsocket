<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>report.md</title></head>
<body><h1>项目设计报告书</h1>
<h2>一、项目题目及功能</h2>
<p><strong>项目题目</strong>：设计一个类似于QQ或MSN的聊天系统。</p>
<p><strong>项目功能</strong>：</p>
<ol start='' ><li>
新用户注册；</li>
<li>
用户登录和退出；</li>
<li>
聊天服务；</li>
<li>
在线用户查询；</li>
<li>
文件传送服务；</li>
<li>
文件断点续传。</li>
</ol>
<h2>二、项目组人员及任务分工</h2>
<p><strong>王炳荃</strong> ：UI界面设计与开发</p>
<p><strong>韩慧</strong> ：文档撰写与设计</p>
<p><strong>李春洋</strong> ：服务器搭建及命令行模式客户端开发</p>
<h2>三、项目整体设计框架图及说明</h2>
<h3>概述</h3>
<p><strong>运行环境搭建</strong> ：采用64位Linux操作系统。推荐使用ubuntu16.04 x64。调用了<code>glib</code>和<code>sqlite3</code>, 编译运行需安装好<code>glib</code>与<code>sqlite</code>的开发库（详细安装过程见 <strong>七</strong> ）。</p>
<p><strong>数据库创建：</strong> 数据库主要用于记录注册人员信息。</p>
<p>基于以上两个条件，程序才可运行。客户端登录时先判断是否已<strong>注册</strong> ，若用户已注册，直接输入账号和密码点击登录即可；若未注册，则需点击注册进入注册界面，输入用户名、密码和确认密码；无操作需求则点击退出。</p>
<p>用户<strong>登录</strong> 时，服务器会随机分配一个<strong>token</strong> 标识，进入QQ界面后，好友<strong>列表</strong> 显示在线用户，选择某一在线用户，即可与其进行聊天和<strong>文件传输</strong> 。</p>
<p>文件传输时，划分文件区块，每次传输信息前附加文件区块信息，实现文件的 <strong>断点续传</strong> 功能。</p>
<p></p>
<p><img src='img/all.png' alt='' /></p>
<p><em>由于程序编写与设计时，两人分工不同，沟通不畅通，导致UI没有完全实现服务器功能。且在服务器调试过程中，需要有客户端调试。因此最终产生了两种客户端，一为命令行界面，一为UI界面。</em> </p>
<h3>服务器设计</h3>
<p>服务器采用<strong>epoll</strong>方法，单进程单线程<strong>多路复用</strong>方式进行<strong>TCP</strong>的传输。整个服务器运行期间存有以下几个哈希表</p>
<table>
<thead>
<tr><th>键</th><th>值</th></tr></thead>
<tbody><tr><td>用户名</td><td>sockfd</td></tr><tr><td>token</td><td>用户名</td></tr><tr><td>用户名</td><td>昵称</td></tr><tr><td>sockfd</td><td>event</td></tr><tr><td>sockfd</td><td>senddata</td></tr></tbody>
</table>
<p>采用<strong>哈希表</strong>保存临时数据，实现了数据的快速查找。</p>
<p>当收到用户信息时，服务器处理用户信息，并调用<code>SendToFd</code>函数，将要发送的数据放到<code>sock2data</code>指向的链表中。</p>
<p>第二次epoll时，从链表中循环读取要发送的数据，发送数据并释放数据占用的内存。</p>
<p></p>
<h3>命令行式客户端设计</h3>
<p>采用<strong>多进程</strong> 模式。两个进程：</p>
<ul><li>
从键盘读取数据，解析用户命令，并向服务器发送数据</li>
<li>
从服务器接收消息，解析数据包，并显示给用户</li>
</ul>
<p>两个进程之间采用<strong>共享内存</strong> 的方式进行数据的传输，共享的数据有用户登录的token，用户名，用户昵称等信息。</p>
<h3>UI客户端设计</h3>
<p>采用<strong>gtk框架</strong>，实现可视化的UI设计。UI采用<strong>多线程</strong> 模式，副线程从服务器接收信息，主线程向服务器发送信息。副线程接收到消息后，采用信号量等方式将数据传输到主线程，并由主线程进行信息的最终绘制过程。</p>
<p></p>
<p></p>
<h2>四、项目分模块设计说明、流程图</h2>
<h3>命令行下客户端具有的功能与相应命令</h3>
<ul><li>
<strong>通用模块</strong></li>
</ul>
<p><code>#help</code> //显示帮助
<code>#status</code> //显示客户端目前状态（是否在线，如果在线的话显示用户名）
<code>#exit</code>// 退出程序，正常登出</p>
<ul><li>
<strong>用户管理模块</strong></li>
</ul>
<p><code>#signup [username] [password] [nickname]</code>//注册用户
<code>#login [username] [password]</code> //登录用户
<code>#logout</code>  //退出登录</p>
<p><code>#showlist</code> //显示所有已登录用户</p>
<ul><li>
<strong>信息交流模块</strong></li>
</ul>
<p><code>#sendto [sendto_username] [data]</code> //向某一用户发送信息</p>
<p>// sendto_username: 要发送的目标用户名,
// data: 发送的数据</p>
<ul><li>
<strong>文件传输模块</strong></li>
</ul>
<p><code>#showfiles</code> //显示服务器已存在的文件
<code>#sendfile [filename] [dstfilename]</code>//向服务器发送文件</p>
<p>//filename： 要发送的文件名
//dstfilename： 服务器端保存的文件名
<code>#recvfile [filename] [id=0]</code>// 从服务器下载文件
//filename 服务器的文件名
//id 断点续传的文件块，默认为0</p>
<p></p>
<p><img src='img/2.png' alt='' /></p>
<h2>五、项目关键数据结构及说明</h2>
<h3>客户端到服务器</h3>
<p><img src='others/clientToServer.png' alt='clientToServer' /></p>
<h3>服务器到客户端</h3>
<p></p>
<p><img src='others/ServerToClient.png' alt='ServerToClient' /></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<h3>数据报头</h3>
<h4>客户端到服务器</h4>
<table>
<thead>
<tr><th>HEAD_MAIN</th><th>HEAD_USER</th></tr></thead>
<tbody><tr><td>char mode</td><td>char logmode; char username[16];char password[16];char nickname[16];</td></tr><tr><td>1</td><td>49</td></tr></tbody>
</table>
<table>
<thead>
<tr><th style='text-align:center;' >discript</th><th>HEAD_MAIN mode</th><th>HEAD_USER logmode</th><th>char username</th><th>char password</th><th>char nickname</th></tr></thead>
<tbody><tr><td style='text-align:center;' >login（登录）</td><td>0</td><td>1</td><td><code>username</code></td><td><code>password</code></td><td>[]</td></tr><tr><td style='text-align:center;' >signup（注册）</td><td>0</td><td>0</td><td><code>username</code></td><td><code>password</code></td><td><code>nickname</code></td></tr></tbody>
</table>
<table>
<thead>
<tr><th>HEAD_MAIN</th><th>HEAD_DATA</th></tr></thead>
<tbody><tr><td>char mode</td><td>char token[44];char datamode;int datalen;</td></tr><tr><td>1</td><td>49</td></tr></tbody>
</table>
<table>
<thead>
<tr><th>discript</th><th>HEAD_MAIN mode</th><th>token</th><th>HEAD_DATA datamode</th><th>int datalen</th></tr></thead>
<tbody><tr><td>logout（登出）</td><td>0</td><td><code>token</code></td><td>0</td><td>0</td></tr><tr><td>senddata（向某一用户发送消息）</td><td>0</td><td><code>token</code></td><td>1</td><td><code>len</code></td></tr><tr><td>sendfile（客户端向服务器发送文件）</td><td>0</td><td><code>token</code></td><td>10</td><td><code>len</code></td></tr><tr><td>recvfile（客户端接收服务器存储的文件）</td><td>0</td><td><code>token</code></td><td>20</td><td><code>len</code></td></tr><tr><td>showfile（服务器文件列表）</td><td>0</td><td><code>token</code></td><td>3</td><td>0</td></tr><tr><td>showlist（显示在线用户）</td><td>0</td><td><code>token</code></td><td>2</td><td>0</td></tr></tbody>
</table>
<h5>客户端到服务器附加数据</h5>
<ul><li>
senddata（向某一用户发送消息）</li>
</ul>
<p><code>struct client_to_server_send_to_user_head</code></p>
<pre lang='c'>
struct client_to_server_send_to_user_head{
	char username[16];
	int len;
};
</pre>
<table>
<thead>
<tr><th>discript</th><th>结构体属性</th><th>大小</th></tr></thead>
<tbody><tr><td>direction user</td><td>username</td><td>16</td></tr><tr><td>data len</td><td>len</td><td>int</td></tr><tr><td>data</td><td>???</td><td>???</td></tr></tbody>
</table>
<ul><li>
<p>sendfile（客户端向服务器发送文件）
<code>struct SEND_FILE</code></p>
<pre lang='c'>
struct SEND_FILE{
	char filename[32];
	unsigned int id;
	unsigned int perlength;
	unsigned long filelength;
};
</pre>
</li>
</ul>
<table>
<thead>
<tr><th>discript</th><th>结构体属性</th><th>大小</th></tr></thead>
<tbody><tr><td>文件名</td><td>filename</td><td>32</td></tr><tr><td>文件分块ID</td><td>id</td><td>unsigned int</td></tr><tr><td>文件分块大小</td><td>perlength</td><td>unsigned int</td></tr><tr><td>发送文件总大小</td><td>filelength</td><td>unsigned long</td></tr></tbody>
</table>
<h4>服务器到客户端</h4>
<p><code>struct HEAD_RETURN</code></p>
<pre lang='c'>
struct HEAD_RETURN{
	char mode;
	char succ;//是否成功
	unsigned int datalen;
}HEAD_RETURN;
</pre>
<table>
<thead>
<tr><th>discript</th><th>mode</th><th>succ</th><th>datalen</th></tr></thead>
<tbody><tr><td>login（登录）</td><td>11</td><td>0 or 1</td><td><code>len</code></td></tr><tr><td>signup（注册）</td><td>12</td><td>0 or 1</td><td>0</td></tr><tr><td>another user login（登录的用户被其他人登录，自动下线）</td><td>13</td><td>0 or 1</td><td>0</td></tr><tr><td>logout（登出）</td><td>21</td><td>0 or 1</td><td>0</td></tr><tr><td>showlist（显示在线用户列表）</td><td>22</td><td>0 or 1</td><td><code>len</code></td></tr><tr><td>showfile（显示服务器文件列表）</td><td>23</td><td>0 or 1</td><td><code>len</code></td></tr><tr><td>senddata（自己的消息是否成功）</td><td>20</td><td>0 or 1</td><td>0</td></tr><tr><td>receive data（其他人发送来的消息）</td><td>99</td><td>0</td><td><code>len</code></td></tr><tr><td>recv sendfile(服务器接收到文件)</td><td>35</td><td>0 or 1</td><td><code>len</code></td></tr><tr><td>sendto user sendfile（服务器向客户端发送文件）</td><td>30</td><td>0 or 1</td><td><code>len</code></td></tr><tr><td>token error（用户登录异常）</td><td>50</td><td>1</td><td>0</td></tr></tbody>
</table>
<p><strong>succ==0 successful; succ!=0 unsuccessful（0为成功）</strong></p>
<h5>服务器返回附加数据</h5>
<ul><li>
server_login_return（登录成功返回附加数据）</li>
</ul>
<pre lang='c'>
struct server_login_return{
    char nickname[16];
    char token[32];
}server_login_return;
</pre>
<table>
<thead>
<tr><th>discript</th><th>结构体属性</th><th>大小</th></tr></thead>
<tbody><tr><td>登录用户的昵称</td><td>nickname</td><td>16</td></tr><tr><td>标识用户身份的令牌</td><td>token</td><td>32</td></tr></tbody>
</table>
<ul><li>
list_per_user（显示已登录用户  返回附加数据）</li>
</ul>
<pre lang='c'>
struct list_per_user{
	char username[16];
	char nickname[16];
}list_per_user;
</pre>
<table>
<thead>
<tr><th>discript</th><th>结构体属性</th><th>大小</th></tr></thead>
<tbody><tr><td>第一个登录用户的用户名</td><td>username</td><td>16</td></tr><tr><td>第一个用户的昵称</td><td>nickname</td><td>16</td></tr><tr><td>第二个登录用户的用户名</td><td>username</td><td>16</td></tr><tr><td>第二个用户的昵称</td><td>nickname</td><td>16</td></tr><tr><td>...</td><td>...</td><td>16</td></tr></tbody>
</table>
<p><strong>HEAD_RETURN的datalen为     登录用户数量*sizeof(list_per_user)</strong></p>
<p></p>
<ul><li>
showfile（显示服务器文件列表）</li>
</ul>
<pre lang='c'>
struct list_per_file{
	char filename[32];
	unsigned long size;
};
</pre>
<p>返回n个<code>list_per_file</code>结构体，根据<code>HEAD_RETURN</code>中<code>datalen</code>判断n的大小。</p>
<p><strong>datalen = n*sizeof(list_per_user)</strong></p>
<table>
<thead>
<tr><th>discript</th><th>结构体属性</th><th>大小</th></tr></thead>
<tbody><tr><td>文件名</td><td>filename</td><td>32</td></tr><tr><td>文件大小</td><td>size</td><td>8</td></tr></tbody>
</table>
<ul><li>
receive data（其他人发送来的消息）</li>
</ul>
<pre lang='c'>
struct server_to_client_send_to_user_head{
	char username[16];
	int len;
};
</pre>
<table>
<thead>
<tr><th>discript</th><th>结构体属性</th><th>大小</th></tr></thead>
<tbody><tr><td>发送者用户名</td><td>username</td><td>16</td></tr><tr><td>数据长度</td><td>len</td><td>4</td></tr><tr><td>用户发送数据</td><td>???</td><td>???</td></tr></tbody>
</table>
<p></p>
<ul><li>
recv sendfile(服务器接收到文件)</li>
</ul>
<pre lang='c'>
struct SEND_FILE{
	char filename[32];
	unsigned int id;
	unsigned int perlength;
	unsigned long filelength;
};
</pre>
<table>
<thead>
<tr><th>discript</th><th>结构体属性</th><th>大小</th></tr></thead>
<tbody><tr><td>文件名</td><td>filename</td><td>32</td></tr><tr><td>分块id</td><td>id</td><td>4</td></tr><tr><td>块数据大小</td><td>perlength</td><td>4</td></tr><tr><td>文件总大小</td><td>filelength</td><td>8</td></tr><tr><td>文件块数据</td><td>???</td><td>???</td></tr></tbody>
</table>
<ul><li>
sendto user sendfile（服务器向客户端发送文件）</li>
</ul>
<pre lang='c'>
struct SEND_FILE{
	char filename[32];
	unsigned int id;
	unsigned int perlength;
	unsigned long filelength;
};
</pre>
<table>
<thead>
<tr><th>discript</th><th>结构体属性</th><th>大小</th></tr></thead>
<tbody><tr><td>文件名</td><td>filename</td><td>32</td></tr><tr><td>分块id</td><td>id</td><td>4</td></tr><tr><td>块数据大小</td><td>perlength</td><td>4</td></tr><tr><td>文件总大小</td><td>filelength</td><td>8</td></tr><tr><td>文件块数据</td><td>???</td><td>???</td></tr></tbody>
</table>
<p><strong>注：文件分块大小不能改变</strong></p>
<h2>六、项目关键函数说明及流程图</h2>
<h3>常量定义</h3>
<ul><li>
my.h</li>
</ul>
<pre lang='c'>
#define DEBUG true//是否debug（目前这一定义没用。。）

#define PERSTRLENGTH 200 //分割字符串的最大长度
#define TOKENSIZE 32//token大小

#define FILEPERLEN 1024//文件传输，分块大小
#define SAVEFILEPATH &quot;data&quot;//服务器文件保存目录
#define CLIENTDATAPATH &quot;clientdata&quot;//客户端文件保存目录

#define MAX_EVENTS 100 // 服务器每次循环event上限
#define DATABASENAME &quot;data.sqlite3&quot;//数据库服务器保存位置
</pre>
<h3>函数接口</h3>
<ul><li>
client_recv.c   客户端接收信息封装</li>
</ul>
<pre lang='c'>
struct HEAD_RETURN* client_recv_HEAD_RETURN(int sockfd);
struct server_login_return* client_recv_login_return(int sockfd);
struct server_to_client_send_to_user_head* client_recv_data_return(int sockfd);
struct list_per_user* client_recv_list_return(int sockfd);


int client_recv(int sockfd, char** nickname,char** token);

void message_out(char* data);
void message_out_login_peruser(char* username,char* nickname);

void client_recv_and_out_perlist(int sockfd);
void client_recv_and_out_data(int sockfd);
void message_out_recv_data(char* username,char* data,int len);
</pre>
<ul><li>
mysocket.c   套接字封装</li>
</ul>
<pre lang='c'>
  int Socket(int domain, int type, int protocol);
  int Bind(int sockfd,struct sockaddr* addr,socklen_t size);
  int Listen(int sockfd,int backlog);
  int Accept(int sockfd,struct sockaddr* addr,socklen_t* size);
  int Connect(int sockfd,struct sockaddr* addr,int size);

  ssize_t Send(int sockfd, const void *buf, size_t len, int flags);
  ssize_t Recv(int sockfd, void *buf, size_t len, int flags);

  int CreateClient(char* serverip,int port);
  int CreateServer(int port,int backlog);
</pre>
<ul><li>
mystruct.c  传输结构体封装</li>
</ul>
<pre lang='c'>
struct HEAD_USER_ALL* data_login(char* username,char* password);
struct HEAD_USER_ALL* data_signup(char* username,char* password,char* nickname);

struct HEAD_DATA* data_HEAD_DATA(char* token, int mode,int len);
struct HEAD_DATA* data_logout(char* token);
struct HEAD_DATA* data_showlist(char* token);
struct HEAD_DATA* data_sendto(char* token);
struct HEAD_DATA* data_showfile(char* token);
struct HEAD_DATA* data_sendfile(char* token);

struct HEAD_RETURN* data_head_return(char mode,char succ,unsigned int datalen);
</pre>
<p></p>
<ul><li>
mystring.c  自己实现的字符串操作函数</li>
</ul>
<pre lang='c'>
#define PERSTRLENGTH 200 //分割字符串的最大长度

char** split(char* str); // 分割字符串为2段
char** split_num(char* str,int num);//分割字符串为num段
void free_splitdata(char** data);// 释放分割字符串空间
void free_splitdata_num(char** data,int num);// 释放分割字符串空间

char* itoa(int num);
char* ltoa(long num);
char* ptoa(void* num);
</pre>
<p><strong>可以使用<code>make test_mysring</code>测试</strong></p>
<ul><li>
filetransport.c  文件传输功能的封装</li>
</ul>
<pre lang='c'>
struct SEND_FILE* recv_sendfile_head(int sockfd);
void mergeFiles(char* filename, unsigned int maxid, unsigned int perlength, unsigned long filelength);
struct SEND_FILE* sendfile_head(char* filename, unsigned int id, unsigned int datalen, unsigned long filelength);
void client_sendfile(int sockfd,char* token,char* path,char* filename);
int trave_dir(char* path, struct file_list** data);
void client_startrecv_id(int sockfd,char* token, char* filename,int id,long filelength);
void client_recvfile(int sockfd,char* path,char* token);

</pre>
<p></p>
<ul><li>
encode.c   编码功能封装</li>
</ul>
<pre lang='c'>
char* createToken(int len); // 创建长度len-1的随机字符串（最后一位是&#39;\0&#39;）[需要手工free]
void print16(char* data,int size);// 每个字节以16进制输出
void printAscii(char* data,int size);
char* encodePassword(char* password); // TODO
</pre>
<ul><li>
sql.c   数据库操做封装</li>
</ul>
<pre lang='c'>
int Sqlite3_open(char* name,sqlite3** db);// open database
sqlite3* createDatabase(sqlite3* db);// create new database
sqlite3* databaseInit();//auto open or create database
int sql_createUser(sqlite3* db,char* username,char* password,char* nickname);
int sql_login(sqlite3* db,char* username,char* password,char** gettingnick);
int sql_changeNickname(sqlite3* db,char* username,char* newnickname);
int sql_all(sqlite3* db,char*** data,int* row,int* col);
// sql_all(db,NULL,NULL,NULL); auto printf database data;
/*
	-   sql_all(db,NULL,NULL,NULL);

	-   char** data;
		int row,col;
		sql_all(db,&amp;data,&amp;row,&amp;col);
*/
</pre>
<h2>七．项目文件列表、文件功能说明及项目编译步骤</h2>
<h3>文件目录</h3>
<table>
<thead>
<tr><th>文件</th><th>功能说明</th></tr></thead>
<tbody><tr><td><a href='https://github.com/lichunown/homework-QQsocket/blob/master/client.c'>client.c</a></td><td>客户端主程序</td></tr><tr><td><a href='https://github.com/lichunown/homework-QQsocket/blob/master/client_recv.c'>client_recv.c</a></td><td>客户端接收功能的封装</td></tr><tr><td><a href='https://github.com/lichunown/homework-QQsocket/blob/master/encode.c'>encode.c</a></td><td>传输信息编码</td></tr><tr><td><a href='https://github.com/lichunown/homework-QQsocket/blob/master/filetransport.c'>filetransport.c</a></td><td>文件传输的函数封装</td></tr><tr><td><a href='https://github.com/lichunown/homework-QQsocket/blob/master/g_hash_extend.c'>g_hash_extend.c</a></td><td>扩展glib哈希表功能</td></tr><tr><td><a href='https://github.com/lichunown/homework-QQsocket/blob/master/mysocket.c'>mysocket.c</a></td><td>套接字封装</td></tr><tr><td><a href='https://github.com/lichunown/homework-QQsocket/blob/master/mystring.c'>mystring.c</a></td><td>字符串处理</td></tr><tr><td><a href='https://github.com/lichunown/homework-QQsocket/blob/master/mystruct.c'>mystruct.c</a></td><td>定义传输结构体</td></tr><tr><td><a href='https://github.com/lichunown/homework-QQsocket/blob/master/server.c'>server.c</a></td><td>服务器主程序</td></tr><tr><td><a href='https://github.com/lichunown/homework-QQsocket/blob/master/sql.c'>sql.c</a></td><td>数据库封装</td></tr><tr><td>test_*.c</td><td>测试单元功能</td></tr></tbody>
</table>
<h3>编译步骤</h3>
<ul><li>
to use sqlite3(for ubuntu)</li>
</ul>
<pre lang='bash'>
sudo apt-get install sqlite3 
sudo apt-get install libsqlite3-dev
</pre>
<ul><li>
use glib
(glib download)[<a href='http://ftp.acc.umu.se/pub/GNOME/sources/glib/2.54/' target='_blank' >http://ftp.acc.umu.se/pub/GNOME/sources/glib/2.54/</a>]</li>
</ul>
<pre lang='undefined'>
wget http://ftp.gnome.org/pub/gnome/sources/glib/2.54/glib-2.54.2.tar.xz
tar -xvJf ./glib-2.54.2.tar.xz
cd ./glib-2.54.2.tar.xz

sudo apt-get install gcc
sudo apt-get install zlib1g-dev
sudo apt-get install pkg-config
sudo apt-get install libffi-dev
sudo apt-get install gettext
sudo apt-get install libmount-dev
sudo apt-get install libpcre3-dev

make
make install

# show the gcc option 
pkg-config glib-2.0 --libs


sudo cp -r /usr/local/include/glib-2.0/* /usr/include/  
sudo cp /usr/local/lib/glib-2.0/include/glibconfig.h /usr/include/
</pre>
<p>or      <a href='https://www.cnblogs.com/tiantao/archive/2012/04/23/2466942.html'>Linux下静态编译glib</a></p>
<pre lang='undefined'>
./configure --prefix=/usr/local/glib --enable-static --disable-shared CFLAGS=&quot;-static&quot;
</pre>
<p><a href='http://blog.csdn.net/andylauren/article/details/51346388'>ubuntu完整安装glib心得</a></p>
<ul><li>
build test</li>
</ul>
<pre lang='bash'>
make test
</pre>
<ul><li>
build server</li>
</ul>
<pre lang='bash'>
make 
</pre>
<ul><li>
build all</li>
</ul>
<pre lang='bash'>
make all
</pre>
<ul><li>
运行</li>
</ul>
<pre lang='bash'>
./server 8001 # 可以不输入端口号，默认8001
# another shell
./client.out 0.0.0.0 8001 # 两个参数分别为连接的IP 和端口号
</pre>
<h2>七．项目演示步骤</h2>
<h3>命令行下客户端截图</h3>
<ul><li>
登录功能</li>
</ul>
<p><img src='img/img_login.png' alt='' /></p>
<ul><li>
注册功能</li>
</ul>
<p><img src='img/img_signup.png' alt='' /></p>
<ul><li>
接收消息</li>
</ul>
<p><img src='img/img_recvdata.png' alt='' /></p>
<ul><li>
文件传输
<img src='img/other5.png' alt='' />
<img src='img/other6.png' alt='' /></li>
<li>
显示列表</li>
</ul>
<p><img src='img/img_showlist.png' alt='' /></p>
<h3>UI界面截图</h3>
<ul><li>
<p>登录
<img src='img/ui_login.png' alt='' /></p>
</li>
<li>
<p>注册
<img src='img/ui_signup.png' alt='' /></p>
</li>
<li>
<p>添加好友
<img src='img/ui_addfriend.png' alt='' /></p>
</li>
<li>
<p>显示好友列表 
<img src='img/ui_showlist.png' alt='' /></p>
</li>
<li>
<p>信息交互
<img src='img/ui_chat.png' alt='' />
<img src='img/ui_chat2.png' alt='' /></p>
<h2>附录</h2>
<p><strong>项目源代码及文件已托管到github：</strong>
<strong><a href='https://github.com/lichunown/homework-QQsocket'>QQsocket</a></strong></p>
</li>
</ul>
</body>
</html>